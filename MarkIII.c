#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           flywheel1,     tmotorVex393HighSpeed_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port2,           Intake,        tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           Indexer,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           flywheel2,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           flywheel3,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          flywheel4,     tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

#pragma systemFile

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/*///////////////////////////////////////////////////////////
/////____________/\\\\\____/\\\\\\\\\_____              /////
///// ________/\\\\////___/\\\///////\\\___             /////
/////  _____/\\\///_______\///______\//\\\__            /////
/////   ___/\\\\\\\\\\\______________/\\\/___           /////
/////    __/\\\\///////\\\_________/\\\//_____          /////
/////     _\/\\\______\//\\\_____/\\\//________         /////
/////      _\//\\\______/\\\____/\\\/___________        /////
/////       __\///\\\\\\\\\/____/\\\\\\\\\\\\\\\_       /////
/////        ____\/////////_____\///////////////__      /////
///// Mark III Robot                                     /////
///// Main Code                                         /////
///// Authors: Jonathan Damico (jj_damico@yahoo.com)    /////
///// Since: Jan. 15, 2016                              /////
*////////////////////////////////////////////////////////////

#warning "setLeftWheelSpeed"
/** Sets the speeds of all the left wheels. **/
void setLeftWheelSpeed (int speed) {
  motor[leftWheel1]   = speed;
  motor[leftWheel2]   = speed;
  motor[leftWheel3]   = speed;
}

#warning "setRightWheelSpeeds"
/** Sets the speeds of all the right wheels. **/
void setRightWheelSpeed (int speed) {
  motor[rightWheel1]  = speed;
  motor[rightWheel2]  = speed;
  motor[rightWheel3]  = speed;
}

//Intake is on back of robot
#warning "setWheelSpeeds"
/** Sets the speeds of all wheels. **/
void setWheelSpeeds (int left, int right) {
  setLeftWheelSpeed(left);
  setRightWheelSpeed(right);
}

#warning "tankDrive"
/** Controlls the drivebase. **/
void tankDrive () {

	int rawLeft = vexRT(Ch3);
	int rawRight = vexRT(Ch2);

	if( rawLeft > 0 )
		setLeftWheelSpeed( rawLeft*rawLeft < 3 ? 0 : rawLeft*rawLeft/127 );
	else
		setLeftWheelSpeed( rawLeft*rawLeft < 3 ? 0 : rawLeft*rawLeft/-127 );

	if( rawRight > 0 )
		setRightWheelSpeed( rawRight*rawRight < 3 ? 0 : rawRight*rawRight/127 );
	else
		setRightWheelSpeed( rawRight*rawRight < 3 ? 0 : rawRight*rawRight/-127 );

}

#warning "orient"
/** Orients robot with gryo **/
float	Kp = 0.05;
float	Ki = 0.22;
float	Kd = 0.07;
task orient () {
	float error, integral, derivative, lastError;
	int speed;

	while (true) {
			//P
			error = 0 - SensorValue[gyro];

			//I
			if(error == 0)
				integral = 0;
			else if (abs(error)>10)
				integral = 0;
			else
				integral += error;

			//D
			derivative = error - lastError;

			lastError = error;


			speed = Kp*error+Ki*integral+Kd*derivative;
			if(speed>-5 && speed<5)
				speed = 0;
			else if(speed>127)
				speed = 127;
			else if(speed<-127)
				speed = -127;
			else if(speed<19 && speed>0)
				speed = 21;
			else if(speed>-19 && speed<0)
				speed = -21;
			setWheelSpeeds(-speed,speed);
	}
}

#warning "Flywheel Instance Variables"
bool lastUpButton=false;
bool lastDownButton=false;
bool currentUpButton;
bool currentDownButton;
int currentGoalVelocity=70;
int currentVelocity;

float error=0;
float integral=0;
int output;
int velocities[5];
#warning "flywheelVelocity"
task flywheelVelocity(){
	int nextIndex=0;
	while(true){
		velocities[nextIndex]=getMotorVelocity(flywheel1);
		nextIndex++;
		if(nextIndex==5)
			nextIndex=0;
		delay(5);
	}
}

#warning "getFlywheelVelocity"
int getFlywheelVelocity(){
	int sum=0;
	for(int i=0;i<5;i++)
		sum = sum + velocities[i];
	return sum/5;
}

#warning "flywheelControl"
task flywheelControl(){
	float kP=1.05;
	float kI=0.3;
	while(true){

		currentVelocity = getFlywheelVelocity();//might need work
		error = currentGoalVelocity - currentVelocity;
		integral = integral +error;
		if(integral>(100/kI))
			integral = 100/kI;
		output = error*kP + integral*kI;
		if(output >15){
			if(output>motor[flywheel1]+15){
				motor[flywheel1]=motor[flywheel1]+15;
				}else if(output<motor[flywheel1]-15){
				motor[flywheel1]=motor[flywheel1]-15;
				}else{

				motor[flywheel1]=output;
			}
			}else if(output<0){
			motor[flywheel1]=0;
			integral=0;
		}
		delay(50);
	}
}

void flywheelUpdate () {
	lastUpButton=currentUpButton;
	lastDownButton=currentDownButton;
	currentUpButton = vexRT[Btn5U];
	currentDownButton= vexRT[Btn5D];

	if(currentUpButton && !lastUpButton)
		currentGoalVelocity+=2;
	if(currentDownButton && !lastDownButton)
		currentGoalVelocity-=2;
}

void init() {
	slaveMotor(flywheel2,flywheel1);
	slaveMotor(flywheel3,flywheel1);
	slaveMotor(flywheel4,flywheel1);
	startTask(flywheelVelocity);
	startTask(flywheelControl);
}

void pre_auton() {
  bStopTasksBetweenModes = true;
}

task autonomous() {
	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

task usercontrol() {
	init();
	while (true) {
		flywheelUpdate();
		tankDrive();

	  motor[Intake]=(vexRt[Btn6U]-vexRt[Btn6D])*127;
		motor[Indexer]=(vexRt[Btn6U]-vexRt[Btn6D])*127;

		delay(50);
	}
}
