#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightWheel2,   tmotorVex393TurboSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           flywheel4,     tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port3,           rightWheel13,  tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           flywheel3,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           leftWheel2,    tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           flywheel1,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           flywheel2,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           leftWheel13,   tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           indexer,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          intake,        tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool lastUpButton=false;
bool lastDownButton=false;
bool currentUpButton;
bool currentDownButton;
int currentGoalVelocity=175;//175 for long
int currentVelocity;

float error=0;
float integral=0;
int output;
int velocities[5];
task flywheelVelocity(){
	int nextIndex=0;
	while(true){
		velocities[nextIndex]=getMotorVelocity(flywheel4);
		nextIndex++;
		if(nextIndex==5)
			nextIndex=0;
		delay(5);
	}
}

task velocity() {
	while(true) {
		int velocity1 = getMotorEncoder(flywheel1);
		wait1Msec(50);
		int velocity2 = getMotorEncoder(flywheel1);
		currentVelocity = (velocity2-velocity1)*60000;
		wait1Msec(50);
	}
}

int getFlywheelVelocity(){
	int sum=0;
	for(int i=0;i<5;i++)
		sum = sum + velocities[i];
	return sum/5;
}

task flywheelControl(){
	clearDebugStream();
	float kP=3.1;
	float kI=0.075;
	int limit = 15;
	while(true){

		currentVelocity = getFlywheelVelocity();//might need work
		error = (currentGoalVelocity - currentVelocity);
		integral = integral + error;
		if(integral>(100/kI))
			integral = 100/kI;
		output = error*kP + integral*kI;
		if(output >25){
			if(output>motor[flywheel4]+limit){
				motor[flywheel4]=motor[flywheel4]+limit;
				}else if(output<motor[flywheel4]-limit){
				motor[flywheel4]=motor[flywheel4]-limit;
				}else{

				motor[flywheel4]=output;
			}
			}else if(output<0){
			motor[flywheel4]=0;
			//integral=0;
		}
		writeDebugStreamLine("Motors: %d, Error: %d, P: %d, I: %d Integral: %d", motor[flywheel1], error, error*kP, integral*kI, integral);
		delay(45);
	}
}
int motortestspeed = 70;
task main()
{
	slaveMotor(flywheel2,flywheel4);
	slaveMotor(flywheel3,flywheel4);
	slaveMotor(flywheel1,flywheel4);
	startTask(flywheelVelocity);
	startTask(flywheelControl);



	while(true){
	//motor[flywheel1]=70;
	//writeDebugStreamLine("%d",getMotorVelocity(flywheel4));

		lastUpButton=currentUpButton;
		lastDownButton=currentDownButton;
		currentUpButton = vexRT[Btn5U];
		currentDownButton = vexRT[Btn5D];

		if(currentUpButton && !lastUpButton)
			currentGoalVelocity+=2;
		if(currentDownButton && !lastDownButton)
			currentGoalVelocity-=2;

	motor[leftWheel13] = vexRT(Ch3);
	motor[leftWheel2] = vexRT(Ch3);
	motor[rightWheel13] = vexRT(Ch2);
	motor[rightWheel2] = vexRT(Ch2);

		//motor[Intake]=(vexRt[Btn6U]-vexRt[Btn6D])*127;
		//motor[Indexer]=(vexRt[Btn6U]-vexRt[Btn6D])*127;

		if(vexRT(Btn8D))
			stopAllTasks();

		motor[Intake] = 127;
		motor[Indexer] = 127;
		delay(50);
	}

}
