#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in2,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  encoderError,   sensorLEDtoVCC)
#pragma config(Sensor, dgtl2,  flywheelEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  indexHigh,      sensorTouch)
#pragma config(Sensor, dgtl5,  indexLow,       sensorTouch)
#pragma config(Sensor, dgtl9,  encoderTest,    sensorTouch)
#pragma config(Sensor, dgtl10, tune,           sensorTouch)
#pragma config(Sensor, dgtl11, debug,          sensorTouch)
#pragma config(Sensor, dgtl12, upToSpeed,      sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightWheel2,   tmotorVex393TurboSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           flywheel4,     tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           rightWheel13,  tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port4,           flywheel3,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           leftWheel2,    tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           flywheel1,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           flywheel2,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           leftWheel13,   tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port9,           indexer,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          intake,        tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(0)
#pragma userControlDuration(60)
#pragma systemFile            	// eliminates warning for "unreferenced" functions

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//Stores the differient speeds for the velocity states of the robot
enum { VELOCITY_LONG 		= 840, 	VELOCITY_MID 		= 640, 	VELOCITY_PIPE 		= 570, 		VELOCITY_HOLD 		= 300 };
enum { HIGH_SPEED_LONG 	= 127,	HIGH_SPEED_MID 	= 127,	HIGH_SPEED_PIPE 	= 127,		HIGH_SPEED_HOLD 	= 90 };
enum { LOW_SPEED_LONG 	= 60, 	LOW_SPEED_MID 	= 45, 	LOW_SPEED_PIPE 		= 40, 		LOW_SPEED_HOLD 		= 45 };
enum { RAMP_LONG 				= 58, 	RAMP_MID 				= 45, 	RAMP_PIPE 				= 45, 		RAMP_HOLD 				= 45 };
enum { WAIT_LONG 				= 580, 	WAIT_MID 				= 0, 		WAIT_PIPE 				= 0, 			WAIT_HOLD 				= 0 };

bool debugMode = false;

int flywheelVelocity;
int flywheelTargetVelocity;
int flywheelHighSpeed;
int flywheelLowSpeed;
int flywheelRampThreshold;
int flywheelReverseStartThreshold = 10;

int intakeWaitTime;
int intakeMoveDownTime = 250;
bool intakeAutonomousIntake;
bool intakeAutonomousIndexer;
bool intakeAutonomousShoot;

#include "JonLib/Drivebase.h"

#warning "setLeftWheelSpeed"
void setLeftWheelSpeed ( int speed ) {
	motor[leftWheel13] = speed;
	motor[leftWheel2] = speed;
}

//Sets the speed of the wheels on the right side of the robot
#warning "setRightWheelSpeed"
void setRightWheelSpeed ( int speed ) {
	motor[rightWheel13] = speed;
	motor[rightWheel2] = speed;
}

//Logarithmic drivebase control
#warning "logDrive"
void logDrive () {
	setWheelSpeed(
	abs(vexRT(Ch3))*vexRT(Ch3)/127,
	(abs(vexRT(Ch2))*vexRT(Ch2)/127)>100?100:abs(vexRT(Ch2))*vexRT(Ch2)/127);
}

task flywheelVelocityCalculation() {
	long lastSysTime = nSysTime;
	while(true) {
		flywheelVelocity = (((float)-SensorValue[flywheelEncoder])/360)/(((float)(nSysTime-lastSysTime)==0?1:(float)(nSysTime-lastSysTime)/(float)60)/1000);
		SensorValue[flywheelEncoder] = 0;
		lastSysTime = nSysTime;
		delay(5);
	}
}

void flywheelLCD () {
	clearLCDLine(0);
	displayLCDNumber(0,1,flywheelVelocity);
	displayLCDNumber(0,5,flywheelTargetVelocity);
	displayLCDNumber(0,10,motor[flywheel4]);
}

void flywheelLED() {
	if(motor[flywheel4]>90)
		SensorValue[upToSpeed] = 1;
	else
		SensorValue[upToSpeed] = 0;
}

void flywheelRampUp (int target) {
	while(motor[flywheel4] < target)
		motor[flywheel4]+=3;
}

#warning "flywheelControl"
task flywheelControl() {
	float kP = 0.63;

	motor[flywheel4] = 25;

	flywheelRampUp (flywheelLowSpeed);

	int flywheelSpeedA, flywheelSpeedB;
	while(true) {

		flywheelSpeedA = flywheelHighSpeed + (flywheelTargetVelocity-flywheelVelocity) * kP;
		flywheelSpeedB = flywheelLowSpeed + (flywheelTargetVelocity-flywheelVelocity) * kP;

		flywheelSpeedA = flywheelSpeedA>100?100:flywheelSpeedA;
		flywheelSpeedB = flywheelSpeedB>100?100:flywheelSpeedB;

		if(flywheelVelocity < flywheelTargetVelocity+flywheelRampThreshold) {
			motor[flywheel4] = flywheelSpeedA;
		} else {
			motor[flywheel4] = flywheelSpeedB;
		}

		if(debugMode) {
			flywheelLCD();
			flywheelLED();
		}

		delay(30);
	}
}

void startFlywheel (int targetVelocity, int lowSpeed, int highSpeed, int rampThreshold, int waitTime = 0) {
	flywheelTargetVelocity = targetVelocity;
	flywheelLowSpeed = lowSpeed;
	flywheelHighSpeed = highSpeed;
	flywheelRampThreshold = rampThreshold;
	intakeWaitTime = waitTime;
	if(flywheelVelocity > 0)
		startTask(flywheelControl, kHighPriority);
	else
		motor[flywheel4] = 0;
}

void stopFlywheel () {
	stopTask(flywheelControl);
	motor[flywheel4] = 0;
}

task intakeControl () {
	while(true) {
		motor[intake] = ((vexRT(Btn5U)||intakeAutonomousIntake)-vexRT(Btn5D))*127;

		//Move ball from high limit switch to low limit switch
		if(vexRT(Btn6D) && SensorValue[indexHigh]) {
			motor[indexer] = -127;
			delay(intakeMoveDownTime);
		}

		//Shooting control
		else if (vexRT(Btn6U) || intakeAutonomousShoot) {
			if(getFlywheelVelocity()>0 && time1[T1]>intakeWaitTime) {
				motor[indexer] = 127;
				while(SensorValue[indexHigh] && (vexRT(Btn6U)||intakeAutonomousShoot)) { delay(5); }
				clearTimer(T1);
			}
			else {
				motor[indexer] = (SensorValue[indexHigh])?-7:127;
			}
		}

		//Move ball down even if there is a sensor we want
		else if (vexRT(Btn5D))
			motor[indexer] = -127;

		//Stop ball if ball is at a sensor
		else if(SensorValue[indexLow] || SensorValue[indexHigh])
			motor[indexer] = -7;

		//Only move ball when we want to
		else
			motor[indexer] = (vexRT(Btn5U)-vexRT(Btn5D))*127;

		delay(30);
	}
}

void reverseFlywheel () {
	stopFlywheel();
	if(flywheelVelocity > flywheelReverseStartThreshold)
		motor[flywheel4] = -5;
	else if (flywheelVelocity <= flywheelReverseStartThreshold)
		motor[flywheel4] = -127;
}

#warning "init"
void init() {
	playTone(700,10);

	setBaudRate(UART1, baudRate57600);

	//Slave Motors
	slaveMotor(flywheel2,flywheel4);
	slaveMotor(flywheel3,flywheel4);
	slaveMotor(flywheel1,flywheel4);

	//Startup modes
	if(!debugMode)
		debugMode = (bool) SensorValue[debug];

	intakeAutonomousIndexer = false;
	intakeAutonomousIntake = false;
	intakeAutonomousIndexer = false;

	startTask(intakeControl);
	startTask(flywheelVelocity);
}

void pre_auton()
{
  bStopTasksBetweenModes = true;
}

task autonomous()
{
	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

task usercontrol() {

	init();

	while (true) {

	  logDrive();

	  if(vexRT(Btn7L))
	  	reverseFlywheel();
	 	else
	 		motor[flywheel4] = 0;

	 	if(vexRT(Btn8U))
			startFlywheel(VELOCITY_PIPE, HIGH_SPEED_PIPE, LOW_SPEED_PIPE, RAMP_PIPE, WAIT_PIPE);

		else if(vexRT(Btn8R))
			startFlywheel(VELOCITY_MID, HIGH_SPEED_MID, LOW_SPEED_MID, RAMP_MID, WAIT_MID);

		else if(vexRT(Btn8L))
			startFlywheel(VELOCITY_LONG, HIGH_SPEED_LONG, LOW_SPEED_LONG, RAMP_LONG, WAIT_LONG);

		else if(vexRT(Btn7D))
			startFlywheel(VELOCITY_HOLD, HIGH_SPEED_HOLD, LOW_SPEED_HOLD, RAMP_HOLD, WAIT_HOLD);

		else if(vexRT(Btn8D))
			stopFlywheel();

	}
}
