#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in8,    indexHigh,      sensorLineFollower)
#pragma config(Sensor, dgtl1,  encoderError,   sensorLEDtoVCC)
#pragma config(Sensor, dgtl10, tune,           sensorNone)
#pragma config(Sensor, dgtl11, debug,          sensorTouch)
#pragma config(Sensor, dgtl12, encoderTest,    sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightWheel2,   tmotorVex393TurboSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           flywheel4,     tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port3,           rightWheel13,  tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           flywheel3,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           leftWheel2,    tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           flywheel1,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           flywheel2,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           leftWheel13,   tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           indexer,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          intake,        tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(0)
#pragma userControlDuration(60)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/*///////////////////////////////////////////////////////////
/////____________/\\\\\____/\\\\\\\\\_____              /////
///// ________/\\\\////___/\\\///////\\\___             /////
/////  _____/\\\///_______\///______\//\\\__            /////
/////   ___/\\\\\\\\\\\______________/\\\/___           /////
/////    __/\\\\///////\\\_________/\\\//_____          /////
/////     _\/\\\______\//\\\_____/\\\//________         /////
/////      _\//\\\______/\\\____/\\\/___________        /////
/////       __\///\\\\\\\\\/____/\\\\\\\\\\\\\\\_       /////
/////        ____\/////////_____\///////////////__      /////
///// Mark III Robot                                    /////
///// Driver Skills Code                              	/////
///// Authors: Jonathan Damico (jj_damico@yahoo.com)    /////
///// Since: Jan. 22, 2016                              /////
*////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////
/// JUMPER CABLE CONFIGURATIONS																		///
///	dgtl10 = tune mode (acts like you're holding down 5U and 6U)	///
///	dgtl11 = debug mode (logs flywheel info to debug stream)			///
///	dgtl12 = encoder test mode (checks encoder works at runtime)	///
/////////////////////////////////////////////////////////////////////
//DEBUG VARIABLES
bool tuneMode = false; //acts like you're holding 5U and 6U
bool debugMode = false; //prints to console

enum { VELOCITY_LONG = 172, VELOCITY_HOLD = 30, VELOCITY_PIPE = 130 }; //MAY NEED TO SWITCH BACK TO typedef and a name before the semicolon

#warning "setLeftWheelSpeed"
void setLeftWheelSpeed ( int speed = 127 ) {
	motor[leftWheel13] = speed;
	motor[leftWheel2] = speed;
}

#warning "setRightWheelSpeed"
void setRightWheelSpeed ( int speed = 127 ) {
	motor[rightWheel13] = speed;
	motor[rightWheel2] = speed;
}

#warning "setWheelSpeed"
void setWheelSpeed ( int leftWheelSpeed = 127, int rightWheelSpeed = 127 ) {
	setLeftWheelSpeed(leftWheelSpeed);
	setRightWheelSpeed(rightWheelSpeed);
}

#warning "logDrive"
void logDrive () {
	int rawLeft, rawRight, outLeft, outRight;
	rawLeft = vexRT(Ch3);
	rawRight = vexRT(Ch2);

	outLeft = rawLeft*rawLeft/127;
	outRight = rawRight*rawRight/127;

	if(rawLeft<0)
		outLeft*=-1;
	if(rawRight<0)
		outRight*=-1;

	setWheelSpeed(outLeft,outRight);
}

bool lastUpButton=false;
bool lastDownButton=false;
bool currentUpButton;
bool currentDownButton;
int currentGoalVelocity=VELOCITY_LONG;
int currentVelocity;

float error=0;
float integral=0;
int output;
int velocities[5];
#warning "flywheelVelocity"
task flywheelVelocity(){
	int nextIndex=0;
	while(true){
		velocities[nextIndex]=getMotorVelocity(flywheel4);
		nextIndex++;
		if(nextIndex==5)
			nextIndex=0;
		delay(5);
	}
}

#warning "getFlywheelVelocity"
int getFlywheelVelocity(){
	int sum=0;
	for(int i=0;i<5;i++)
		sum = sum + velocities[i];
	return sum/5;
}

bool flywheelOn = false;
#warning "flywheelControl"
task flywheelControl(){
	flywheelOn = true;
	clearDebugStream();

	float kP=1.0;
	float kI=0.05736;
	int limit = 15;
	while(true){

		currentVelocity = getFlywheelVelocity();//might need work
		error = (currentGoalVelocity - currentVelocity);
		integral = integral + error;
		if(integral>(100/kI))
			integral = 100/kI;
		output = error*kP + integral*kI;
		if(output >25){
			if(output>motor[flywheel4]+limit){
				motor[flywheel4]=motor[flywheel4]+limit;
			}else if(output<motor[flywheel4]-limit){
				motor[flywheel4]=motor[flywheel4]-limit;
			}else{
				motor[flywheel4]=output;
			}
		}else if(output<0){
			motor[flywheel4]=0;
			//integral=0;
		}
		if(debugMode)
			writeDebugStreamLine("Motors: %d, Error: %d, P: %d, I: %d Integral: %d", motor[flywheel1], error, error*kP, integral*kI, integral);
		delay(80);
	}
}

bool flywheelHold = false;
#warning "startFlywheel"
void startFlywheel (int targetVelocity) {
	currentGoalVelocity = targetVelocity;
	if(targetVelocity == (int) VELOCITY_HOLD) {
		motor[flywheel4] = VELOCITY_HOLD;
		stopTask(flywheelVelocity);
		stopTask(flywheelControl);
		flywheelHold = true;
	} else if(!flywheelOn || flywheelHold) {
		startTask(flywheelVelocity);
		startTask(flywheelControl);
		flywheelHold = false;
	}
}

bool autoIntake = false;
void startAutoFlywheel (int targetVelocity) {
	startFlywheel(targetVelocity);
	autoIntake = false;
}

#warning "stopFlywheel"
task stopFlywheel () {
	flywheelOn = false;
	autoIntake = false;
	stopTask(flywheelControl);
	while(motor[flywheel4]>0){
		motor[flywheel4] -= 1;
		delay(20);
	}
	stopTask(flywheelVelocity);
	stopTask(stopFlywheel);
}

#warning "autoLoad"
void autoLoad () {
	startFlywheel(VELOCITY_LONG);
	autoIntake = true;
}

int ballIndexerLimit = 2000;
int velocityTime = 400;
int velocityLimit = 23;
#warning "intakeControl"
task intakeControl () {
	while(true) {
		motor[intake]=(tuneMode+vexRT[Btn5U]-vexRT[Btn5D])*127;

		if(vexRT(Btn5U)||tuneMode) {
			if(SensorValue[indexHigh]>ballIndexerLimit) {
				motor[indexer] = (tuneMode+vexRT[Btn5U]-vexRT[Btn5D])*127;
			} else if (time1[T1]>velocityTime && (vexRT(Btn6U) || tuneMode) && (abs(currentGoalVelocity-currentVelocity)<velocityLimit)) {
				motor[indexer] = (tuneMode+vexRT[Btn5U]-vexRT[Btn5D])*127;
				delay(90);
				clearTimer(T1);
			} else {
				motor[indexer] = 0;
			}
		} else if(vexRT(Btn5D)) {
			motor[indexer] = (tuneMode+vexRT[Btn5U]-vexRT[Btn5D])*127;
		} else {
			motor[indexer] = 0;
		}
	}
		//if(SensorValue[indexHigh]>=ballIndexerLimit && (vexRT(Btn5U) || tuneMode)) {
		//	motor[indexer] = (tuneMode+vexRt[Btn5U]-vexRt[Btn5D])*127;
		//} else if(!vexRT(Btn5D) && time1[T1]<velocityTime && /*abs(currentGoalVelocity-currentVelocity)>velocityLimit &&*/ SensorValue[indexHigh]<ballIndexerLimit) {
		//	motor[indexer] = 0;
		//} else if((vexRT(Btn5U) && vexRT(Btn6U)) || tuneMode || autoIntake || vexRT(Btn5D)) {
		//	motor[indexer] = (tuneMode+vexRt[Btn5U]-vexRt[Btn5D])*127;
		//	if(time1[T1]>velocityTime+150) {
		//		clearTimer(T1);
		//	}
  //  } else {
		//	motor[indexer] = 0;
		//}
}

#warning "testEncoder"
void testEncoder () {
	int recordedEncoderValue1, recordedEncoderValue2;
	SensorValue[encoderError] = 0;
	startFlywheel(VELOCITY_LONG);
	clearTimer(T3);
	bool performsWell = false;
	delay(1000);
	while(time1[T3]<5000 && !performsWell) {
		recordedEncoderValue1 = nMotorEncoder[flywheel4];
		delay(50);
		recordedEncoderValue2 = nMotorEncoder[flywheel4];
		if(recordedEncoderValue1!=recordedEncoderValue2)
			performsWell = true;
		delay(50);
	}
	if(performsWell)
		SensorValue[encoderError] = 1;
	else
		SensorValue[encoderError] = 0;
	startTask(stopFlywheel);
}

#warning "init"
void init() {
	slaveMotor(flywheel2,flywheel4);
	slaveMotor(flywheel3,flywheel4);
	slaveMotor(flywheel1,flywheel4);
	startTask(intakeControl);
	debugMode = (bool) SensorValue[debug];
	tuneMode = (bool) SensorValue[tune];
}

void pre_auton() {
	bStopTasksBetweenModes = true;
}

task autonomous() {
	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

task usercontrol() {

	if(SensorValue[encoderTest])
		testEncoder();

	init();

	while (true) {
		lastUpButton=currentUpButton;
		lastDownButton=currentDownButton;
		currentUpButton = (bool)vexRT[Btn5U];
		currentDownButton = (bool)vexRT[Btn5D];

		if(vexRT(Btn8R))
			startAutoFlywheel(VELOCITY_PIPE);

		else if(vexRT(Btn8D))
			startAutoFlywheel(VELOCITY_HOLD);

		else if(vexRT(Btn8L))
			startAutoFlywheel(VELOCITY_LONG);

		else if(vexRT(Btn8U))
			startTask(stopFlywheel);

		else if(vexRT(Btn7D))
			autoLoad();

		if(currentUpButton && !lastUpButton)
			currentGoalVelocity+=2;
		if(currentDownButton && !lastDownButton)
			currentGoalVelocity-=2;

		logDrive();

	}
}
